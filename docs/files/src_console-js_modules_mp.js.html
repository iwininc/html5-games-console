<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/console-js/modules/mp.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/GettingStarted.html">GettingStarted</a></li>
            
                <li><a href="../classes/iConsole.ads.html">iConsole.ads</a></li>
            
                <li><a href="../classes/iConsole.game.html">iConsole.game</a></li>
            
                <li><a href="../classes/iConsole.iap.html">iConsole.iap</a></li>
            
                <li><a href="../classes/iConsole.mp.html">iConsole.mp</a></li>
            
                <li><a href="../classes/iConsole.mp.simple.html">iConsole.mp.simple</a></li>
            
                <li><a href="../classes/iConsole.periodical.html">iConsole.periodical</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/console-js/modules/mp.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(iConsole, Class, Module){

    /**
     * Multiplayer
     * ----------------
     * todo later - Docs need done as we get to the point of filling out this implementation
     * @class iConsole.mp
     * @type {iConsole.mp|*|{}}
     */
    var MP = Class.create(Module, {

        LOBBY_STATE_WAITING: &quot;waiting&quot;,
        LOBBY_STATE_PLAYING: &quot;playing&quot;,
        LOBBY_STATE_FINISHED: &quot;finished&quot;,
        LOBBY_STATE_DECIDING: &quot;deciding&quot;,

        USER_TYPE_VOYEUR: &quot;voyeur&quot;,
        USER_TYPE_REAL: &quot;real&quot;,
        USER_TYPE_GUEST: &quot;guest&quot;,

        LOBBY_ROOM_STATE_GAME_STARTED: &quot;game_started&quot;,
        LOBBY_ROOM_STATE_GAME_ENDED: &quot;game_ended&quot;,
        LOBBY_ROOM_STATE_GAME_WAITING: &quot;waiting&quot;,


        initModule:function($super, data){
            $super(data);
        },

        init:function($super, data){
            $super(data);
            iConsole.game.onEvent(&#x27;mpSimpleTournamentStarted&#x27;, iConsole.mp.simple.internal.mpSimpleTournamentStarted);
            iConsole.game.onEvent(&#x27;mpSimpleSkillzExited&#x27;, iConsole.mp.simple.internal.mpSimpleSkillzExited);
        },

        /**
         * This function determines whether mutilplayer support has been enabled.
         * If you were expecting it to have been enabled check your game_details.json config w.r.t. multiplayer additions.
         * For most games this will return false.
         * @method isSupported
         * @return {boolean}
         */
        isSupported: function() {
            return iConsole.mp.internal.supported;
        },

        /**
         * This function allows you to register a callback handler for each tick of game state. Game state is polled every n seconds.
         * @method registerGetState
         * @param callback {Function} The callback function you want to be called back on. The callback will receive a populated object as follows
         * @example
         * &lt;pre&gt;
         * {
         *   game_room_id: &quot;...&quot;,                                                        //internal id of no use to you as a game developer
         *   server_time: ...,                                                           //milliseconds since unix epoch
         *   users: [                                                                    //users who are part of this room
         *     { id: &quot;...&quot;, nickname: &quot;...&quot;,  avatar_url: &quot;...&quot; , state: { ... } }       //state is whatever you pass up
         *     { ... }
         *     { ... }
         *   ]
         * }
         * &lt;/pre&gt;
         */
        registerGetState: function(callback) {
            iConsole.mp.internal.getStateCallback = callback;
        },


        /**
         * This function should be used to initiate a user and assign him to the a Room in the multiplayer service.
         * @return {Object} An object which contains two functions, success and failure, which should each be called
         * with the function you wish to call when the assignment succeeds or fails. These calls can be directly chained:
         * @example
         * &lt;pre&gt;
         *     iConsole.mp.autoAssignUserToRoom().success(mySuccessFunction).failure(myFailureFunction);
         * &lt;/pre&gt;
         */
        autoAssignUserToRoom: function() {
            return (function(){
                var successCallback = null;
                var failureCallback = null;
                iConsole.XDM.sendAutoAssignUserToRoom({user_id: iConsole.mp.internal.user_id}).result(function(data) {
                    if (data.status === &#x27;OK&#x27;) {
                        iConsole.mp.internal.game_room_id = data.room_id;
                        if (successCallback) {
                            successCallback();
                        }
                    } else if (failureCallback) {
                        failureCallback();
                    }
                });
                var returnable = {
                    success: function(callback) {
                        successCallback = callback;
                        return returnable;
                    },
                    failure: function(callback) {
                        failureCallback = callback;
                        return returnable;
                    }
                };
                return returnable;
            })();
        },


        /**
         * This function should be used to flag that the user has started playing the game at the point where lobby activities
         * have concluded and the game client feels it has enough users to begin.
         * @method gameStarted
         * @param options {Object} The method accepts an options object which may be expanded later with behaviours for how
         * additional users join the game once it has started.
         * @return {Object} An object which contains two functions, success and failure, which should each be called
         * with the function you wish to call when the assignment succeeds or fails. These calls can be directly chained:
         * @example
         * &lt;pre&gt;
         *     iConsole.mp.gameStarted(options).success(mySuccessFunction).failure(myFailureFunction);
         * &lt;/pre&gt;
         */
        gameStarted: function (options) {
            return iConsole.mp.internal.updateLobbyRoomState(iConsole.mp.LOBBY_ROOM_STATE_GAME_STARTED);
        },

        /**
         * This function should be used to flag that the game client has ended the game for all players.
         * @method gameEnded
         * @param options {Object} The method accepts an options object which may be expanded later with behaviours that
         * affect what happens to the user at game end.
         * @return {Object} An object which contains two functions, success and failure, which should each be called
         * with the function you wish to call when the assignment succeeds or fails. These calls can be directly chained:
         * @example
         * &lt;pre&gt;
         *     iConsole.mp.gameEnded(options).success(mySuccessFunction).failure(myFailureFunction);
         * &lt;/pre&gt;
         */
        gameEnded: function(options) {
            return iConsole.mp.internal.updateLobbyRoomState(iConsole.mp.LOBBY_ROOM_STATE_GAME_ENDED);
        },

        /**
         * This function should be used to update the current players state - other game clients will be responsible for updating
         * their own player&#x27;s state.
         * @method updateState
         * @param state {Object} A small state object representing all the data about the user that other game clients need in order
         * to display the status of that user, examples include board state in jewel quest, number of questions answered correctly
         * in a quiz game and so on.
         * @return {Object} An object which contains two functions, success and failure, which should each be called
         * with the function you wish to call when the assignment succeeds or fails. These calls can be directly chained:
         * @example
         * &lt;pre&gt;
         *     iConsole.mp.updateState({score: 45}).success(mySuccessFunction).failure(myFailureFunction);
         * &lt;/pre&gt;
         */
        updateState: function(state) {
            return iConsole.mp.internal.pushStateToServer( state );
        },

        /**
         * This function should be used by the game to set the players lobby state accordingly.
         * For example a user can be either &#x27;playing&#x27;   or   &#x27;deciding&#x27;.
         * Most players are &#x27;waiting&#x27; when they join a room and remain in this state until the game determines it has enough users to start.
         * At this point each client should update their user into &#x27;playing&#x27; state.
         * The user stays in this state until the user finishes their game, at which point they should be moved to &#x27;finished&#x27; status.
         * When you show the &quot;play again&quot;   or   &quot;leave room&quot; screen the user should be placed into a &#x27;deciding&#x27; status.
         * This allows users to either play again or leave and prevents the game believing it has the correct number of users
         * already available to start the game.
         * Users in the &#x27;finished&#x27; or &#x27;deciding&#x27; status are still technically in the room and take up a players spot until they leave.
         * Once a user agrees to play again (or is automatically agreed to play again) they should be set to &#x27;playing&#x27; status.
         * @param lobbyState, must be either iConsole.mp.LOBBY_STATE_WAITING, iConsole.mp.LOBBY_STATE_PLAYING, iConsole.mp.LOBBY_STATE_FINISHED,
         * iConsole.mp.LOBBY_STATE_DECIDING
         * @return {Object} An object which contains two functions, success and failure, which should each be called
         * with the function you wish to call when the assignment succeeds or fails. These calls can be directly chained:
         * @example
         * &lt;pre&gt;
         *     iConsole.mp.updateUsersLobbyState(iConsole.mp.LOBBY_STATE_WAITING).success(mySuccessFunction).failure(myFailureFunction);
         * &lt;/pre&gt;
         */
        updateUsersLobbyState: function(lobbyState) {
            if (iConsole.mp.internal.game_room_id !== null &amp;&amp; iConsole.mp.internal.game_room_id !== undefined) {
                return (function(){
                    var successCallback = null;
                    var failureCallback = null;
                    iConsole.XDM.sendUpdateUsersLobbyState({ user_id: iConsole.mp.internal.user_id,
                        game_room_id: iConsole.mp.internal.game_room_id,
                        lobby_state: lobbyState }).result(function(data) {
                        if (data.status === &#x27;OK&#x27;) {
                            if (successCallback) {
                                successCallback();
                            }
                        } else if (failureCallback) {
                            failureCallback();
                        }
                    });
                    var returnable = {
                        success: function(callback) {
                            successCallback = callback;
                            return returnable;
                        },
                        failure: function(callback) {
                            failureCallback = callback;
                            return returnable;
                        }
                    };
                    return returnable;
                })();
            }
        },

        /**
        * This function accepts the users passed to the  getState  callback handler and returns the current player&#x27;s object.
        * You should check this response for null - which signifies that the current user could not be located.
        */
        getCurrentPlayer: function (allUsers, voyeur_users) {
            for (var x = 0; x &lt; allUsers.length; x++) {
                if (allUsers[x].id === iConsole.mp.internal.user_id) {
                    return allUsers[x];
                }
            }

            for (var y = 0; y &lt; voyeur_users.length; y++) {
                if (voyeur_users[y].id === iConsole.mp.internal.user_id) {
                    return voyeur_users[y];
                }
            }

            return null;
        },

        /**
        * This function accepts the users passed to the  getState  callback handler and returns the other player objects.
        * You should check this response for being empty.
        * Note the current user will never appear in this list...
        * Also note that when users leave a room at any point, they will not appear in the list returned here.
        * The game clients should keep track of which players were playing and their last recorded state and compare that with the list of players still playing.
        */
        getOtherPlayers: function (allUsers) {
            var otherUsers = [];
            for (var x = 0; x &lt; allUsers.length; x++) {
                if (allUsers[x].id !== iConsole.mp.internal.user_id) {
                    otherUsers.push(allUsers[x]);
                }
            }
            return otherUsers;
        },


        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users waiting.
         */
        getWaitingUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_WAITING);
        },

        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users playing.
         */
        getPlayingUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_PLAYING);
        },

        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users finished playing.
         */
        getFinishedUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_FINISHED);
        },

        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users deciding,
         * i.e. still in the room but not yet agreed to play again.
         */
        getDecidingUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_DECIDING);
        },

        /**
         * This function allows the game to show a button to allow the user to leave the game at any point in time.
         * When called it will remove the user from the game.
         * @return {Object} An object which contains two functions, success and failure, which should each be called
         * with the function you wish to call when the assignment succeeds or fails. These calls can be directly chained:
         * @example
         * &lt;pre&gt;
         *     iConsole.mp.userLeftRoom().success(mySuccessFunction).failure(myFailureFunction);
         * &lt;/pre&gt;
         */
        userLeftRoom: function( ) {
            return (function(){
                var successCallback = null;
                var failureCallback = null;
                iConsole.XDM.sendRemoveUserFromRoom({ user_id: iConsole.mp.internal.user_id,
                                                      game_room_id: iConsole.mp.internal.game_room_id }).result(function(data) {
                    if (data.status === &#x27;OK&#x27;) {
                        if (successCallback) {
                            iConsole.mp.internal.game_room_id = null;
                            successCallback();
                        }
                    } else if (failureCallback) {
                        failureCallback();
                    }
                });
                var returnable = {
                    success: function(callback) {
                        successCallback = callback;
                        return returnable;
                    },
                    failure: function(callback) {
                        failureCallback = callback;
                        return returnable;
                    }
                };
                return returnable;
            })();
        },

        internal: {
            supported: false,
            getStateCallback: null,
            pollForServerStateInterval: null,
            pollForServerStateDelay: 3000,
            pollForUserAliveDelay: 300000,
            userAliveTimer: (new Date()).getTime(),

            user_id: guid(),
            game_room_id: null,

            initializeMP: function(data) {
                iConsole.mp.internal.supported = true;
                if ( iConsole.mp.internal.supported )
                {
                    iConsole.mp.internal.startPollingServerForState();
                    iConsole.mp.internal.startPollingUserAlive();
                    iConsole.mp.internal.pollForServerStateDelay = data.state_poll_every_n_seconds * 1000;
                }
            },

            updateLobbyRoomState: function(state) {
                if (iConsole.mp.internal.game_room_id !== null &amp;&amp; iConsole.mp.internal.game_room_id !== undefined) {
                    return (function(){
                        var successCallback = null;
                        var failureCallback = null;
                        iConsole.XDM.sendUpdateLobbyRoomState({game_room_id: iConsole.mp.internal.game_room_id, room_state: state}).result(function(data) {
                            if (data.status === &#x27;OK&#x27;) {
                                if (successCallback) {
                                    successCallback();
                                }
                            } else if (failureCallback) {
                                failureCallback();
                            }
                        });
                        var returnable = {
                            success: function(callback) {
                                successCallback = callback;
                                return returnable;
                            },
                            failure: function(callback) {
                                failureCallback = callback;
                                return returnable;
                            }
                        };
                        return returnable;
                    })();
                }
            },

            pushStateToServer: function(state) {
                if (iConsole.mp.internal.game_room_id !== null &amp;&amp; iConsole.mp.internal.game_room_id !== undefined) {
                    iConsole.mp.internal.userAliveTimer = (new Date()).getTime();
                    return (function(){
                        var successCallback = null;
                        var failureCallback = null;
                        iConsole.XDM.sendPushStateToServer({ user_id: iConsole.mp.internal.user_id,
                            game_room_id: iConsole.mp.internal.game_room_id,
                            user_state: state }).result(function(data) {
                            if (data.status === &#x27;OK&#x27;) {
                                if (successCallback) {
                                    successCallback();
                                }
                            } else if (failureCallback) {
                                failureCallback();
                            }
                        });
                        var returnable = {
                            success: function(callback) {
                                successCallback = callback;
                                return returnable;
                            },
                            failure: function(callback) {
                                failureCallback = callback;
                                return returnable;
                            }
                        };
                        return returnable;
                    })();
                }
            },

            postUserAlive: function() {
                var now = (new Date().getTime());
                if ((now - iConsole.mp.internal.pollForUserAliveDelay) &gt; iConsole.mp.internal.userAliveTimer) {
                    iConsole.mp.internal.pushStateToServer(null);
                }
            },

            startPollingServerForState: function() {
                iConsole.mp.internal.pollForServerStateInterval = setInterval(iConsole.mp.internal.pollForServerState, iConsole.mp.internal.pollForServerStateDelay);
            },

            startPollingUserAlive: function() {
                iConsole.mp.internal.pollForServerStateInterval = setInterval(iConsole.mp.internal.postUserAlive, iConsole.mp.internal.pollForUserAliveDelay);
            },

            pollForServerState: function() {
                if (iConsole.mp.internal.game_room_id !== null &amp;&amp; iConsole.mp.internal.game_room_id !== undefined) {
                    iConsole.XDM.sendPollForServerState({ game_room_id: iConsole.mp.internal.game_room_id })
                        .result(function(data) {
                            if (data !== null) {
                                var json = data;
                                if (json.status !== false) {
                                    iConsole.mp.internal.performCallback(iConsole.mp.internal.getStateCallback, json);
                                }
                            }
                        });
                }
            },

            performCallback: function (theFunction, callbackWith) {
                if (theFunction !== undefined &amp;&amp; theFunction) {
                    if (callbackWith !== null) {
                        theFunction(callbackWith);
                    }
                    else {
                        theFunction();
                    }
                }
            },

            getUsersWithLobbyState: function (allUsers, someType) {
                var users = [];
                for (var x = 0; x &lt; allUsers.length; x++) {
                    if (allUsers[x].lobby_state === someType) {
                        users.push(allUsers[x]);
                    }
                }
                return users;
            }
        },
        /**
         * Simple Multiplayer Mode
         * ---------------
         *
         * Within our mobile application, we have the potential to integrate with an asynchronous Multiplayer experience
         * currently partnering with Skillz. This multiplayer experience works such that you can initiate the
         * Multiplayer experience, which loads up the third party UI, allowing the user to join an asynchronous
         * gaming tournament (which could be head to head, or n players, or play as many times in a given time frame to
         * attempt to get the highest score). Once the game has made the choice to work in Multiplayer mode, it must
         * behave differently than normal, in such that the game is not listening to a user input for when the game
         * should start, or what type of level to show the user, but instead listen to callbacks from this API as to
         * when a level should be started.
         *
         * During the progress of a level, the game should regularly report the user&#x27;s current score (this could be
         * every n seconds, or whenever the score is increased). This is such that it is easier to determine if foul
         * play has come in to effect. Remember that users can and will be playing for REAL MONEY as well as virtual
         * currency.
         *
         * The typical flow would be to:
         * * register the session started callback, to ensure that your game is notified of
         * when the MP experience has determined the user is about to start a tournament
         * * register the exit multiplayer callback, to ensure that the game is aware of what mode it should be working
         * in
         * * Either bind a button to the startMultiplayer (i.e. a Start Multiplayer Mode button on the UI), or if the
         * game is going to launch straight in to Multiplayer mode, to call startMultiplayer when it is fully configured
         * and ready to start listening to the callbacks for the tournament session started.
         * * When the callback to the session started has occurred, you should read the attributes passed in the object
         * to callback function, to determine any configuration needed to be applied. For example a tournament may be
         * configured to disable all collectible powerups, to further increase difficulty. The game session should then
         * begin.
         * * During a game session, if you are playing in a Multiplayer session, you should report regularly the players
         * score, to ensure that foul play can be detected by the third party provider.
         * * Once a game has completed, you should endSession with the users score. At this point the game should be
         * prepared to receive a callback on either the session started callback, or the exiting multiplayer callback
         * * If the game offers the ability, if the user ends their current game, it should call abortSession to notify
         * the third party the player has forfeited their tournament.
         *
         * It should be noted that on the mobile application (but not on the desktop console), the
         * &lt;code&gt;Math.random&lt;/code&gt; object will be overridden with a slightly slower implementation. This implementation
         * will ensure that all players in a given ongoing tournament will have the same random seed at the start of
         * their game session. This should mean that all players see the same initial state. Your game should not
         * (unless explicitly required to do so) take any other factors in to account when attempting to use a random
         * number (i.e. don&#x27;t do Math.random() * 10000 + Date.now() - oldTimeStamp). In the case of a traditional
         * Match 3 game, this should mean that two players with the same seed, should be able to play identical moves
         * and see identical elements on their board at each move. Scoring should not be using any random element, but
         * can use time (to reward faster activity for example).
         *
         * To verify this behavior on a desktop console, append #!mpsimpledebug to the url of the console/game url:
         * http://s.games.iwin.com/m/console/v_217/#/m/iwin/bubble-town-quest/v_117/#!mpsimpledebug
         *
         *
         * This indicates to the console that it should say that the iConsole.mp.simple.isSupported should return true,
         * and allow for debug calls to be made on the Javascript Console.
         *
         *
         * When your game implements the iConsole.mp.simple calls, you will see the javascript console report this:
         * * iConsole.game.exitApplication - &quot;Game has requested to exit the application - unsupported on this client&quot;
         * * iConsole.mp.simple.startMultiplayer - an Alert box will appear on screen
         * * iConsole.mp.simple.reportScore - &quot;Game Score reported as XXX&quot; where XXX is the score
         * * iConsole.mp.simple.abortSession - &quot;User aborted game, returning control to game in 5 seconds time&quot;
         * * iConsole.mp.simple.endSession - &quot;Game finished with score XXX returning control to game in 5 seconds time&quot; where XXX is the score
         *
         *
         * Once you have called iConsole.mp.simple.startMultiplayer from the debug desktop javascript console, two
         * methods are available on the window object:
         * &lt;pre&gt;
         * // Call this function from the javascript console to pretend to initiate a new Multiplayer Tournament Session
         * // You can pass in an object which can contain key/value pairs, which will be exposed to the sessionStarted
         * // callback function
         * window.startMPSimpleSession( {
         *     tournamentParam1 : tournamentValue1,
         *     ...
         *     tournamentParamN : tournamentValueN
         * } );
         *
         * // Call this function to pretend to exit out of the multiplayer experience from the third party.
         * window.exitMP();
         * &lt;/pre&gt;
         * @class iConsole.mp.simple
         * @type {iConsole.mp.simple|*|{}}
         */
        simple: {
            /**
             * This asynchronous call should be made to feature flip your game into which mode it should operate in.
             * @return {Object} An object that contains a member function &lt;code&gt;result&lt;/code&gt; that you should call with a
             * callback function that will be fired shortly after this call. The format of result function is
             * &lt;pre&gt;result( callbackFunction );&lt;/pre&gt;
             * Where callbackFunction is a function that will be called with a single parameter, a boolean that will
             * determine if Simple Multiplayer is supported or not.
             * @example
             * &lt;pre&gt;
             * iConsole.mp.simple.isSupported().result( function( supported ) {
             *    if ( supported ) {
             *      myGame.setUpForMultiPlayer();
             *    } else {
             *      myGame.setUpForSinglePlayer();
             *    }
             * } );
             * &lt;/pre&gt;
             * @method isSupported
             */
            isSupported: function() {
                var request = iConsole.XDM.sendMPSimpleIsSupported();
                return {
                    result: function(callback) {
                        request.result(function(data) {
                            if (JSON.stringify(data) === &#x27;{}&#x27;) {
                                callback(false);
                            } else {
                                callback(true);
                            }
                        });
                    }
                };
            },
            /**
             * Register a single callback function that should be called whenever the Multiplayer experience launches a
             * new Tournament session, and requires the game to configure itself accordingly, and then start playing the
             * game.
             * @param callback {Function} The callback function that will be called every time the Multiplayer
             * experience wants to start a new game session. This callback function will be passed an Object which
             * contains a number of values:
             * &lt;pre&gt;
             * {
             *  // A text description of the tournament
             *  matchDescription : &quot;eg: Practice before you go pro!&quot;,
             *
             *  // How much it cost in real cash to join the tournament
             *  entryCash : 0,
             *
             *  // The tournament id
             *  id : 1855266,
             *
             *  // The name of the tournament type
             *  name : &quot;Novice&quot;,
             *
             *  // The amount of virtual currency it cost the user to join the tournament
             *  entryPoints : 1,
             *
             *  // The third party user (not to be confused with the iwin user)
             *  player : {
             *      // User&#x27;s ID
             *      id : 49082,
             *
             *      // User&#x27;s nick name
             *      displayName : &quot;JudiciousTower&quot;,
             *
             *      // a URL for a flag image for the users location
             *      flagURL : &quot;https://cdn.sandbox.skillz.com/flags/US.png&quot;,
             *
             *      // a URL for an image for their avatar
             *      avatarURL : &quot;https://cdn.sandbox.skillz.com/default-profile-pics/Girl2_003.png&quot;
             *  },
             *
             *  // A Flag to identify if this tournament is being played for cash (some tournaments may be offered for
             *  // a cash prize, but with virtual currency as the entry fee)
             *  isCash : false,
             *
             *  // If configured in the third party, we can add multiple key value pairs to the tournament if required,
             *  // they would be listed in this object where XXX is the key name, and YYY is the value
             *  XXX : YYY
             * }
             * &lt;/pre&gt;
             * @example
             * &lt;pre&gt;
             * iConsole.mp.simple.registerSessionStartedCallback( function( tournamentData ) {
             *    myGame.resetGameBoard();
             *    myGame.configureGameBoardForMultiplayer( tournamentData );
             *    myGame.startGameSession();
             * } );
             * &lt;/pre&gt;
             * @method registerSessionStartedCallback
             */
            registerSessionStartedCallback: function(callback) {
                iConsole.mp.simple.internal.sessionStartedCallback = callback;
            },
            /**
             * Register a single callback function that should be called whenever the Multiplayer experience exits. This
             * is typically done by a user action declaring through the third party, that they no longer wish to play
             * the current game in Multiplayer mode. If your game supports both modes of operation, you should return to
             * either a single player mode, or a menu allowing the user to choose the type of play they want to do
             * @param callback {Function} The callback function that will be called every time the Multiplayer
             * experience wants to exit out of Multiplayer mode.
             * @example
             * &lt;pre&gt;
             * iConsole.mp.simple.registerExitMultiplayerCallback( function() {
             *    // Game supports Single Player mode
             *    myGame.resetToSinglePlayerMode();
             * } );
             * &lt;/pre&gt;
             * @example
             * &lt;pre&gt;
             * iConsole.mp.simple.registerExitMultiplayerCallback( function() {
             *    // Game doesn&#x27;t support Single Player mode
             *    iConsole.game.exitApplication();
             * } );
             * &lt;/pre&gt;
             * @method registerExitMultiplayerCallback
             */
            registerExitMultiplayerCallback: function(callback) {
                iConsole.mp.simple.internal.exitMultiplayerCallback = callback;
            },

            /**
             * This function will launch the Multiplayer Experience, and launch the UI from the third party, which
             * handles virtual currency, tournament matching, user identity and launching etc. It should only be called
             * once you have registered your callbacks for session starting and exiting multiplayer mode. An example of
             * when you would call this would either be as the result of a user clicking on a &quot;Play Multiplayer&quot; button,
             * or as part of the game launching process when the game doesn&#x27;t support Single Player.
             * @example
             * &lt;pre&gt;
             * myGame.buttons.multiPlayerMode.onClick = function() {
             *    iConsole.mp.simple.startMultiplayer();
             * };
             * &lt;/pre&gt;
             * @example
             * &lt;pre&gt;
             * iConsole.mp.simple.registerSessionStartedCallback(myGame.mpSessionStartedHandler);
             * iConsole.mp.simple.registerExitMultiplayerCallback(myGame.exitMPHandler);
             * iConsole.mp.startMultiplayer();
             * &lt;/pre&gt;
             * @method startMultiplayer
             */
            startMultiplayer: function() {
                return iConsole.XDM.sendMPSimpleStartMultiplayer();
            },

            /**
             * This function should be called periodically by the game, when you are in a multiplayer gaming session,
             * to update the third party with the user&#x27;s current score.
             * @param score - the numeric score of the user
             * @example
             * &lt;pre&gt;
             * myGame.updateScore = function(score) {
             *     myGame.ui.refreshScore(score);
             *     myGame.ui.animateProgressInLevel(score);
             *     if (myGame.mpInProgress) {
             *         iConsole.mp.simple.reportScore(score);
             *     }
             * }
             * &lt;/pre&gt;
             * @method reportScore
             */
            reportScore: function(score) {
                return iConsole.XDM.sendMPSimpleReportScore({score: score});
            },

            /**
             * This function should be called when the user has voluntarily exited out of the current game (i.e. give
             * up). The game should expect to receive a callback on either the session started or exiting out of
             * multiplayer at some point after this call, when the user decides to either start a new game, or leave
             * the multiplayer experience altogether.
             * @example
             * &lt;pre&gt;
             * myGame.abortLevel = function() {
             *     myGame.ui.showSadAnimation();
             *     if (myGame.mpInProgress) {
             *         myGame.mpInProgress = false;
             *         iConsole.mp.simple.abortSession();
             *     }
             * }
             * &lt;/pre&gt;
             * @method abortSession
             */
            abortSession: function() {
                return iConsole.XDM.sendMPSimpleAbortSession();
            },

            /**
             * This function should be called when the user has reached the end of their game session. The game should
             * expect to receive a callback on either the session started or exiting out of multiplayer at some point
             * after this call, when the user decides to either start a new game, or leave the multiplayer experience
             * altogether.
             * @param score - the numeric score of the user
             * @example
             * &lt;pre&gt;
             * myGame.completeLevel = function(score) {
             *     myGame.ui.showCongratulationsAnimation();
             *     if (myGame.mpInProgress) {
             *         myGame.mpInProgress = false;
             *         iConsole.mp.simple.endSession(score);
             *     }
             * }
             * &lt;/pre&gt;
             * @method endSession
             */
            endSession: function(score) {
                return iConsole.XDM.sendMPSimpleEndSession({score: score});
            },
            /**
             * This asynchronous call can be used to determine if you are currently in a session. It is added more as a
             * helper function, as this is an asynchronous call, and will involve a degree of computational churn which
             * should be avoided if possible.
             * @return {Object} An object that contains a member function &lt;code&gt;result&lt;/code&gt; that you should call with a
             * callback function that will be fired shortly after this call. The format of result function is
             * &lt;pre&gt;result( callbackFunction );&lt;/pre&gt;
             * Where callbackFunction is a function that will be called with a single parameter, a boolean that will
             * determine if a multiplayer session is in play or not.
             * @example
             * &lt;pre&gt;
             * iConsole.mp.simple.inSession().result( function( inSession ) {
             *    if ( inSession ) {
             *      myGame.mpInProgress = true;
             *    } else {
             *      myGame.mpInProgress = false;
             *    }
             * } );
             * &lt;/pre&gt;
             * @method inSession
             */
            inSession: function() {
                var request = iConsole.XDM.sendMPSimpleInSession();
                return {
                    result: function(callback) {
                        request.result(function(data) {
                            callback(data.inSession);
                        });
                    }
                };
            },
            internal : {
                sessionStartedCallback: null,
                exitMultiplayerCallback: null,
                mpSimpleTournamentStarted: function(event) {
                    if (iConsole.mp.simple.internal.sessionStartedCallback) {
                        iConsole.mp.simple.internal.sessionStartedCallback(event.data);
                    }
                },
                mpSimpleSkillzExited: function(event) {
                    if (iConsole.mp.simple.internal.exitMultiplayerCallback) {
                        iConsole.mp.simple.internal.exitMultiplayerCallback(event.data);
                    }
                }
            }
        }
    });

    var m = new MP();

    iConsole.install(&quot;mp&quot;, new MP());

    return m;

})(iConsole, Class, Module);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
