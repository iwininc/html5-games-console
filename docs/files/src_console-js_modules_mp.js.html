<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/console-js/modules/mp.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/GettingStarted.html">GettingStarted</a></li>
            
                <li><a href="../classes/iConsole.ads.html">iConsole.ads</a></li>
            
                <li><a href="../classes/iConsole.game.html">iConsole.game</a></li>
            
                <li><a href="../classes/iConsole.iap.html">iConsole.iap</a></li>
            
                <li><a href="../classes/iConsole.periodical.html">iConsole.periodical</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/console-js/modules/mp.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(iConsole, Class, Module){

    /**
     * Multiplayer
     * ----------------
     * todo later - Docs need done as we get to the point of filling out this implementation
     */
    var MP = Class.create(Module, {

        LOBBY_STATE_WAITING: &quot;waiting&quot;,
        LOBBY_STATE_PLAYING: &quot;playing&quot;,
        LOBBY_STATE_FINISHED: &quot;finished&quot;,
        LOBBY_STATE_DECIDING: &quot;deciding&quot;,

        USER_TYPE_VOYEUR: &quot;voyeur&quot;,
        USER_TYPE_REAL: &quot;real&quot;,
        USER_TYPE_GUEST: &quot;guest&quot;,

        LOBBY_ROOM_STATE_GAME_STARTED: &quot;game_started&quot;,
        LOBBY_ROOM_STATE_GAME_ENDED: &quot;game_ended&quot;,


        initModule:function($super, data){
            $super(data);
        },

        init:function($super, data){
            $super(data);
        },

        /**
         * This function determines whether mutilplayer support has been enabled.
         * If you were expecting it to have been enabled check your game_details.json config w.r.t. multiplayer additions.
         * For most games this will return false.
         * @method isSupported
         * @return {boolean}
         */
        isSupported: function() {
            return iConsole.mp.internal.supported;
        },

        /**
         * This function allows you to register a callback handler for each tick of game state. Game state is polled every n seconds.
         * @method registerGetState
         * @param callback {Function} The callback function you want to be called back on. The callback will receive a populated object as follows
         * @example
         * &lt;pre&gt;
         * {
         *   game_room_id: &quot;...&quot;,                                                        //internal id of no use to you as a game developer
         *   server_time: ...,                                                           //milliseconds since unix epoch
         *   users: [                                                                    //users who are part of this room
         *     { id: &quot;...&quot;, nickname: &quot;...&quot;,  avatar_url: &quot;...&quot; , state: { ... } }       //state is whatever you pass up
         *     { ... }
         *     { ... }
         *   ]
         * }
         * &lt;/pre&gt;
         */
        registerGetState: function(callback) {
            iConsole.mp.internal.getStateCallback = callback;
        },


        /**
         * This function should be used to initiate a user and assign him to the a Room in the multiplayer service.
         * @return {Object} An object which contains two functions, success and failure, which should each be called
         * with the function you wish to call when the assignment succeeds or fails. These calls can be directly chained:
         * @example
         * &lt;pre&gt;
         *     iConsole.mp.autoAssignUserToRoom().success(mySuccessFunction).failure(myFailureFunction);
         * &lt;/pre&gt;
         */
        autoAssignUserToRoom: function() {
            return (function(){
                var successCallback = null;
                var failureCallback = null;
                iConsole.XDM.sendAutoAssignUserToRoom({user_id: iConsole.mp.internal.user_id}).result(function(data) {
                    if (data.status === &#x27;OK&#x27;) {
                        iConsole.mp.internal.game_room_id = data.room_id;
                        if (successCallback) {
                            successCallback();
                        }
                    } else if (failureCallback) {
                        failureCallback();
                    }
                });
                var returnable = {
                    success: function(callback) {
                        successCallback = callback;
                        return returnable;
                    },
                    failure: function(callback) {
                        failureCallback = callback;
                        return returnable;
                    }
                };
                return returnable;
            })();
        },


        /**
         * This function should be used to flag that the user has started playing the game at the point where lobby activities have concluded and the game client feels it has enough users to begin.
         * @method gameStarted
         * @param options {Object} The method accepts an options object which may be expanded later with behaviours for how additional users join the game once it has started.
         */
        gameStarted: function (options) {
            iConsole.mp.internal.updateLobbyRoomState(iConsole.mp.LOBBY_ROOM_STATE_GAME_STARTED);
        },

        /**
         * This function should be used to flag that the game client has ended the game for all players.
         * @method gameEnded
         * @param options {Object} The method accepts an options object which may be expanded later with behaviours that affect what happens to the user at game end.
         */
        gameEnded: function(options) {
            iConsole.mp.internal.updateLobbyRoomState(iConsole.mp.LOBBY_ROOM_STATE_GAME_ENDED);
        },

        /**
         * This function should be used to update the current players state - other game clients will be responsible for updating their own player&#x27;s state.
         * @method updateState
         * @param state {Object} A small state object representing all the data about the user that other game clients need in order to display the status of that user,
         * examples include board state in jewel quest, number of questions answered correctly in a quiz game and so on.
         */
        updateState: function(state) {
            iConsole.mp.internal.pushStateToServer( state );
        },

        /**
         * This function should be used by the game to set the players lobby state accordingly.
         * For example a user can be either &#x27;playing&#x27;   or   &#x27;deciding&#x27;.
         * Most players are &#x27;waiting&#x27; when they join a room and remain in this state until the game determines it has enough users to start.
         * At this point each client should update their user into &#x27;playing&#x27; state.
         * The user stays in this state until the user finishes their game, at which point they should be moved to &#x27;finished&#x27; status.
         * When you show the &quot;play again&quot;   or   &quot;leave room&quot; screen the user should be placed into a &#x27;deciding&#x27; status.
         * This allows users to either play again or leave and prevents the game believing it has the correct number of users already available to start the game.
         * Users in the &#x27;finished&#x27; or &#x27;deciding&#x27; status are still technically in the room and take up a players spot until they leave.
         * Once a user agrees to play again (or is automatically agreed to play again) they should be set to &#x27;playing&#x27; status.
         * @param lobbyState, must be either iConsole.mp.LOBBY_STATE_WAITING, iConsole.mp.LOBBY_STATE_PLAYING, iConsole.mp.LOBBY_STATE_FINISHED, iConsole.mp.LOBBY_STATE_DECIDING
         */
        updateUsersLobbyState: function(lobbyState) {
            return (function(){
                var successCallback = null;
                var failureCallback = null;
                iConsole.XDM.sendUpdateUsersLobbyState({ user_id: iConsole.mp.internal.user_id,
                                                         game_room_id: iConsole.mp.internal.game_room_id,
                                                         lobby_state: lobbyState }).result(function(data) {
                    if (data.status === &#x27;OK&#x27;) {
                        if (successCallback) {
                            successCallback();
                        }
                    } else if (failureCallback) {
                        failureCallback();
                    }
                });
                var returnable = {
                    success: function(callback) {
                        successCallback = callback;
                        return returnable;
                    },
                    failure: function(callback) {
                        failureCallback = callback;
                        return returnable;
                    }
                };
                return returnable;
            })();
        },

        /**
        * This function accepts the users passed to the  getState  callback handler and returns the current player&#x27;s object.
        * You should check this response for null - which signifies that the current user could not be located.
        */
        getCurrentPlayer: function (allUsers, voyeur_users) {
            for (var x = 0; x &lt; allUsers.length; x++) {
                if (allUsers[x].id === iConsole.mp.internal.user_id) {
                    return allUsers[x];
                }
            }

            for (var y = 0; y &lt; voyeur_users.length; y++) {
                if (voyeur_users[y].id === iConsole.mp.internal.user_id) {
                    return voyeur_users[y];
                }
            }

            return null;
        },

        /**
        * This function accepts the users passed to the  getState  callback handler and returns the other player objects.
        * You should check this response for being empty.
        * Note the current user will never appear in this list...
        * Also note that when users leave a room at any point, they will not appear in the list returned here.
        * The game clients should keep track of which players were playing and their last recorded state and compare that with the list of players still playing.
        */
        getOtherPlayers: function (allUsers) {
            var otherUsers = [];
            for (var x = 0; x &lt; allUsers.length; x++) {
                if (allUsers[x].id !== iConsole.mp.internal.user_id) {
                    otherUsers.push(allUsers[x]);
                }
            }
            return otherUsers;
        },


        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users waiting.
         */
        getWaitingUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_WAITING);
        },

        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users playing.
         */
        getPlayingUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_PLAYING);
        },

        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users finished playing.
         */
        getFinishedUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_FINISHED);
        },

        /**
         * This function accepts the users passed to the  getState  callback handler and returns the users deciding, i.e. still in the room but not yet agreed to play again.
         */
        getDecidingUsers: function (allUsers) {
            return iConsole.mp.internal.getUsersWithLobbyState(allUsers, iConsole.mp.LOBBY_STATE_DECIDING);
        },

        /**
         * This function allows the game to show a button to allow the user to leave the game at any point in time.
         * When called it will remove the user from the game.
         */
        userLeftRoom: function( ) {
            return (function(){
                var successCallback = null;
                var failureCallback = null;
                iConsole.XDM.sendRemoveUserFromRoom({ user_id: iConsole.mp.internal.user_id,
                                                      game_room_id: iConsole.mp.internal.game_room_id }).result(function(data) {
                    if (data.status === &#x27;OK&#x27;) {
                        if (successCallback) {
                            successCallback();
                        }
                    } else if (failureCallback) {
                        failureCallback();
                    }
                });
                var returnable = {
                    success: function(callback) {
                        successCallback = callback;
                        return returnable;
                    },
                    failure: function(callback) {
                        failureCallback = callback;
                        return returnable;
                    }
                };
                return returnable;
            })();
        },

        internal: {
            supported: false,
            getStateCallback: null,
            pollForServerStateInterval: null,
            pollForServerStateDelay: 3000,

            user_id: guid(),
            game_room_id: null,

            initializeMP: function(data) {
                iConsole.mp.internal.supported = true;
                if ( iConsole.mp.internal.supported )
                {
                    iConsole.mp.internal.startPollingServerForState();
                    iConsole.mp.internal.pollForServerStateDelay = data.state_poll_every_n_seconds * 1000;
                }
            },

            updateLobbyRoomState: function(state) {
                return (function(){
                    var successCallback = null;
                    var failureCallback = null;
                    iConsole.XDM.sendUpdateLobbyRoomState({game_room_id: iConsole.mp.internal.game_room_id, room_state: state}).result(function(data) {
                        if (data.status === &#x27;OK&#x27;) {
                            if (successCallback) {
                                successCallback();
                            }
                        } else if (failureCallback) {
                            failureCallback();
                        }
                    });
                    var returnable = {
                        success: function(callback) {
                            successCallback = callback;
                            return returnable;
                        },
                        failure: function(callback) {
                            failureCallback = callback;
                            return returnable;
                        }
                    };
                    return returnable;
                })();
            },

            pushStateToServer: function(state) {
                return (function(){
                    var successCallback = null;
                    var failureCallback = null;
                    iConsole.XDM.sendPushStateToServer({ user_id: iConsole.mp.internal.user_id,
                                                         game_room_id: iConsole.mp.internal.game_room_id,
                                                         user_state: state }).result(function(data) {
                        if (data.status === &#x27;OK&#x27;) {
                            if (successCallback) {
                                successCallback();
                            }
                        } else if (failureCallback) {
                            failureCallback();
                        }
                    });
                    var returnable = {
                        success: function(callback) {
                            successCallback = callback;
                            return returnable;
                        },
                        failure: function(callback) {
                            failureCallback = callback;
                            return returnable;
                        }
                    };
                    return returnable;
                })();
            },

            startPollingServerForState: function() {
                iConsole.mp.internal.pollForServerStateInterval = setInterval(iConsole.mp.internal.pollForServerState, iConsole.mp.internal.pollForServerStateDelay);
            },

            pollForServerState: function() {
                iConsole.XDM.sendPollForServerState({ game_room_id: iConsole.mp.internal.game_room_id })
                    .result(function(data) {
                        if (data !== null) {
                            var json = data;
                            iConsole.mp.internal.performCallback(iConsole.mp.internal.getStateCallback, json);
                        }
                });
            },

            performCallback: function (theFunction, callbackWith) {
                if (theFunction !== undefined &amp;&amp; theFunction) {
                    if (callbackWith !== null) {
                        theFunction(callbackWith);
                    }
                    else {
                        theFunction();
                    }
                }
            },

            getUsersWithLobbyState: function (allUsers, someType) {
                var users = [];
                for (var x = 0; x &lt; allUsers.length; x++) {
                    if (allUsers[x].lobby_state === someType) {
                        users.push(allUsers[x]);
                    }
                }
                return users;
            }
        }
    });

    var m = new MP();

    iConsole.install(&quot;mp&quot;, new MP());

    return m;

})(iConsole, Class, Module);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
